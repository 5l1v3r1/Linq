<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Linq by pfultz2</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Linq</h1>
        <p>Linq for list comprehension in C++</p>
        <p class="view"><a href="https://github.com/pfultz2/Linq">View the Project on GitHub <small>pfultz2/Linq</small></a></p>
        <ul>
          <li><a href="https://github.com/pfultz2/Linq/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/pfultz2/Linq/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/pfultz2/Linq">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>Linq</h1>

<p>Linq for list comprehension in C++, provides an implementation of linq for C++. Currently it only supports C++ ranges, but it does support both the extension and query methods for linq. Here's an example:</p>

<div class="highlight"><pre><span class="k">struct</span> <span class="nc">student_t</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">::</span><span class="kt">string</span> <span class="n">last_name</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">scores</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="n">student_t</span><span class="p">&gt;</span> <span class="n">students</span> <span class="p">=</span> 
<span class="p">{</span>
    <span class="p">{</span><span class="s">"Omelchenko"</span><span class="p">,</span> <span class="p">{</span><span class="m">97</span><span class="p">,</span> <span class="m">72</span><span class="p">,</span> <span class="m">81</span><span class="p">,</span> <span class="m">60</span><span class="p">}},</span>
    <span class="p">{</span><span class="s">"O'Donnell"</span><span class="p">,</span> <span class="p">{</span><span class="m">75</span><span class="p">,</span> <span class="m">84</span><span class="p">,</span> <span class="m">91</span><span class="p">,</span> <span class="m">39</span><span class="p">}},</span>
    <span class="p">{</span><span class="s">"Mortensen"</span><span class="p">,</span> <span class="p">{</span><span class="m">88</span><span class="p">,</span> <span class="m">94</span><span class="p">,</span> <span class="m">65</span><span class="p">,</span> <span class="m">85</span><span class="p">}},</span>
    <span class="p">{</span><span class="s">"Garcia"</span><span class="p">,</span> <span class="p">{</span><span class="m">97</span><span class="p">,</span> <span class="m">89</span><span class="p">,</span> <span class="m">85</span><span class="p">,</span> <span class="m">82</span><span class="p">}},</span>
    <span class="p">{</span><span class="s">"Beebe"</span><span class="p">,</span> <span class="p">{</span><span class="m">35</span><span class="p">,</span> <span class="m">72</span><span class="p">,</span> <span class="m">91</span><span class="p">,</span> <span class="m">70</span><span class="p">}}</span> 
<span class="p">};</span>

<span class="n">auto</span> <span class="n">scores</span> <span class="p">=</span> <span class="n">LINQ</span><span class="p">(</span><span class="k">from</span><span class="p">(</span><span class="n">student</span><span class="p">,</span> <span class="n">students</span><span class="p">)</span> 
                   <span class="k">from</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">student</span><span class="p">.</span><span class="n">scores</span><span class="p">)</span> 
                   <span class="k">where</span><span class="p">(</span><span class="n">score</span> <span class="p">&gt;</span> <span class="m">90</span><span class="p">)</span> 
                   <span class="k">select</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">student</span><span class="p">.</span><span class="n">last_name</span><span class="p">,</span> <span class="n">score</span><span class="p">)));</span>

<span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">x</span> <span class="p">:</span> <span class="n">scores</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s score: %i\n"</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">x</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>The C++ code above will outputs this(yes that is C++ code above):</p>

<pre><code>Omelchenko score: 97
O'Donnell score: 91
Mortensen score: 94
Garcia score: 97
Beebe score: 91
</code></pre>

<h2>Extension</h2>

<p>Extensions are implemented using the <code>|</code> pipe operator. This allows them to be applied to any range, without requiring inherting from some special base class. So extensions can work like this:</p>

<div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span> <span class="p">};</span>
<span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">numbers</span> 
        <span class="o">|</span> <span class="n">linq</span><span class="o">::</span><span class="n">where</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">;</span> <span class="p">})</span> 
        <span class="o">|</span> <span class="n">linq</span><span class="o">::</span><span class="n">select</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>
</pre></div>

<p>The extension methods supported are:</p>

<ul>
<li>  aggregate(reducer)</li>
<li>  aggregate(seed, reducer)</li>
<li>  aggregate(seed, reducer, selector)</li>
<li>  all(predicate)</li>
<li>  any(predicate)</li>
<li>  average()</li>
<li>  concat(range)</li>
<li>  contains(element)</li>
<li>  count()</li>
<li>  count(predicat)</li>
<li>  default_if_empty()</li>
<li>  default_if_empty(default_value)</li>
<li>  distinct()</li>
<li>  element_at(index)</li>
<li>  except(range)</li>
<li>  find(element)</li>
<li>  first()</li>
<li>  first(predicate, value)</li>
<li>  first_or_default()</li>
<li>  first_or_default(predicate)</li>
<li>  group_by(key_selector)</li>
<li>  group_by(key_selector, element_selector)</li>
<li>  group_join(range, outer_key_selector, inner_key_selector, result_selector)</li>
<li>  intersect(range)</li>
<li>  join(range, outer_key_selector, inner_key_selector, result_selector)</li>
<li>  keys()</li>
<li>  last()</li>
<li>  last(predicate, value)</li>
<li>  last_or_default()</li>
<li>  last_or_default(predicate)</li>
<li>  max()</li>
<li>  min()</li>
<li>  order_by(selector)</li>
<li>  order_by_descending(selector)</li>
<li>  reverse()</li>
<li>  select(selector)</li>
<li>  select_many(selector)</li>
<li>  sequence_equal(range)</li>
<li>  single()</li>
<li>  single_or_default()</li>
<li>  skip(count)</li>
<li>  skip_while(predicate)</li>
<li>  sum()</li>
<li>  take(count)</li>
<li>  take_while(predicate)</li>
<li>  then_by(selector)</li>
<li>  then_by_descending(selector)</li>
<li>  to_container()</li>
<li>  union(range)</li>
<li>  values()</li>
<li>  where(predicate)</li>
<li>  zip(range)</li>
<li>  zip(range, selector)</li>
</ul><p>The library also provides a <code>range_extension</code> class, that can be used to write your own extensions, as well. First just define the function as a function object class, like this:</p>

<div class="highlight"><pre><span class="k">struct</span> <span class="n">contains_t</span>
<span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Range</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Range</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">r</span> <span class="o">|</span> <span class="n">linq</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">!=</span> <span class="n">boost</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">r</span><span class="p">);</span> <span class="p">};</span>
<span class="p">};</span>
</pre></div>

<p>Then initialize the extension using static initialization:</p>

<div class="highlight"><pre><span class="n">range_extension</span><span class="o">&lt;</span><span class="n">contains_t</span><span class="o">&gt;</span> <span class="n">contains</span> <span class="o">=</span> <span class="p">{};</span>
</pre></div>

<p>Then the extension can be used like this:</p>

<div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">numbers</span> <span class="o">|</span> <span class="n">contains</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="n">printf</span><span class="p">(</span><span class="s">"We have a 5"</span><span class="p">);</span>
</pre></div>

<h2>Query</h2>

<h3>from</h3>

<p>All linq queries must start with a <code>from</code> statement. This specifies the variable name to be used for the lambdas and the container that the queries will be applied to. Also, multiple <code>from</code> statements can be used.</p>

<div class="highlight"><pre><span class="k">struct</span> <span class="nc">student</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">::</span><span class="kt">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">grades</span><span class="p">;</span>

    <span class="n">student</span><span class="p">()</span> <span class="p">{}</span>

    <span class="n">template</span><span class="p">&lt;</span><span class="k">class</span> <span class="nc">Range</span><span class="p">&gt;</span>
    <span class="n">student</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">Range</span><span class="p">&amp;&amp;</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">grades</span><span class="p">(</span><span class="n">boost</span><span class="p">::</span><span class="n">begin</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">boost</span><span class="p">::</span><span class="n">end</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="p">{}</span>
<span class="p">};</span>

<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="n">student</span><span class="p">&gt;</span> <span class="n">students</span> <span class="p">=</span>
<span class="p">{</span>
    <span class="n">student</span><span class="p">(</span><span class="s">"Bob"</span><span class="p">,</span> <span class="p">{</span> <span class="m">90</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="m">75</span> <span class="p">})</span>
    <span class="n">student</span><span class="p">(</span><span class="s">"Tom"</span><span class="p">,</span> <span class="p">{</span> <span class="m">92</span><span class="p">,</span> <span class="m">81</span><span class="p">,</span> <span class="m">70</span> <span class="p">})</span>
    <span class="n">student</span><span class="p">(</span><span class="s">"Terry"</span><span class="p">,</span> <span class="p">{</span> <span class="m">105</span><span class="p">,</span> <span class="m">98</span><span class="p">,</span> <span class="m">94</span> <span class="p">})</span>
<span class="p">};</span>

<span class="c1">// { 90, 100, 75, 92, 81, 70, 105, 98, 94 }</span>
<span class="n">auto</span> <span class="n">q</span> <span class="p">=</span> <span class="n">LINQ</span><span class="p">(</span><span class="k">from</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">students</span><span class="p">)</span> <span class="k">from</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">grades</span><span class="p">)</span> <span class="k">select</span><span class="p">(</span><span class="n">g</span><span class="p">));</span>
</pre></div>

<h3>where</h3>

<p>The where clause returns the element that matches the predicate. It is optional but must come after a <code>from</code> clause and should be before a <code>select</code> clause if there is one.</p>

<div class="highlight"><pre><span class="n">vector</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">v</span> <span class="p">=</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="p">};</span>
<span class="c1">// { 1, 3, 5 }</span>
<span class="n">auto</span> <span class="n">q</span> <span class="p">=</span> <span class="n">LINQ</span><span class="p">(</span><span class="k">from</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">where</span><span class="p">(</span><span class="n">i</span> <span class="p">%</span> <span class="m">2</span><span class="p">));</span>
</pre></div>

<h3>select</h3>

<p>The select clause applies a transformation to the elements. It is optional also, but should be the very last clause.</p>

<div class="highlight"><pre><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">v</span> <span class="p">=</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span> <span class="p">};</span>
<span class="c1">// { 3, 6, 24 }</span>
<span class="n">auto</span> <span class="n">q</span> <span class="p">=</span> <span class="n">LINQ</span><span class="p">(</span><span class="k">from</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">select</span><span class="p">(</span><span class="n">x</span> <span class="p">*</span> <span class="m">3</span><span class="p">));</span>
</pre></div>

<h3>orderby</h3>

<p>The <code>orderby</code> clause lets you specify elements to order the range by. Also <code>ascending</code> or <code>descending</code> can be preceded by the selector in order to specify the direction of ordering. The default is ascending.</p>

<div class="highlight"><pre><span class="k">struct</span> <span class="nc">person</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">::</span><span class="kt">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

    <span class="n">person</span><span class="p">()</span> <span class="p">{}</span>

    <span class="n">person</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">age</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
    <span class="p">{}</span>
<span class="p">};</span>

<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="n">person</span><span class="p">&gt;</span> <span class="n">people</span> <span class="p">=</span>
<span class="p">{</span>
    <span class="n">person</span><span class="p">(</span><span class="s">"Tom"</span><span class="p">,</span> <span class="m">25</span><span class="p">),</span>
    <span class="n">person</span><span class="p">(</span><span class="s">"Bob"</span><span class="p">,</span> <span class="m">22</span><span class="p">),</span>
    <span class="n">person</span><span class="p">(</span><span class="s">"Terry"</span><span class="p">,</span> <span class="m">37</span><span class="p">),</span>
    <span class="n">person</span><span class="p">(</span><span class="s">"Jerry"</span><span class="p">,</span> <span class="m">22</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//  { "Jerry", "Bob", "Tom", "Terry" }</span>
<span class="n">auto</span> <span class="n">q</span> <span class="p">=</span> <span class="n">LINQ</span><span class="p">(</span><span class="k">from</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">people</span><span class="p">)</span> <span class="k">orderby</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">age</span><span class="p">,</span> <span class="k">descending</span> <span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="k">select</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">));</span>
</pre></div>

<h3>group</h3>

<p>The <code>group</code> clause groups the elements of a sequence. The first parameter is the key selector, and the second one is the value selector.</p>

<div class="highlight"><pre><span class="k">struct</span> <span class="nc">person</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">::</span><span class="kt">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

    <span class="n">person</span><span class="p">()</span> <span class="p">{}</span>

    <span class="n">person</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">age</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
    <span class="p">{}</span>
<span class="p">};</span>

<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="n">person</span><span class="p">&gt;</span> <span class="n">people</span> <span class="p">=</span>
<span class="p">{</span>
    <span class="n">person</span><span class="p">(</span><span class="s">"Tom"</span><span class="p">,</span> <span class="m">25</span><span class="p">),</span>
    <span class="n">person</span><span class="p">(</span><span class="s">"Bob"</span><span class="p">,</span> <span class="m">22</span><span class="p">),</span>
    <span class="n">person</span><span class="p">(</span><span class="s">"Terry"</span><span class="p">,</span> <span class="m">37</span><span class="p">),</span>
    <span class="n">person</span><span class="p">(</span><span class="s">"Jerry"</span><span class="p">,</span> <span class="m">22</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">auto</span> <span class="n">q</span> <span class="p">=</span> <span class="n">LINQ</span><span class="p">(</span><span class="k">from</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">people</span><span class="p">)</span> <span class="k">group</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">age</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">));</span>
</pre></div>

<h2>Installation</h2>

<p>Just copy the <code>linq.h</code> and <code>linq</code> folder to the include directory for your compiler. Then just include the <code>linq.h</code> header, to include all of linq.</p>

<p>The <code>linq/extensions.h</code> header will just include whats needed for the extension methods, without the query syntax, and the <code>linq/query.h</code> will include the query syntax as well.</p>

<h2>Requirements</h2>

<p>For full support it requires clang or gcc, and boost. There is partial support for visual studio. Visual studio doesn't support the <code>default_if_empty</code>, <code>group_by</code>, <code>group_join</code>, <code>join</code>, <code>order_by</code>, <code>select_many</code>, and <code>then_by</code> extensions, and it doesn't support <code>orderby</code>, <code>group</code>, and nested from clauses. Perhaps some visual studio wizards could help find workarounds for msvc bugs.  </p>

<h2>Limitations</h2>

<p>Multiple <code>from</code> statements are implemented using nested lambdas. However, because of a <a href="http://connect.microsoft.com/VisualStudio/feedback/details/634688">bug</a> in MSVC 2010, nested lambas don't work(This should be fixed in MSVC 2012, but I haven't tested it). If there is a way to implement transparent identifiers in C++, nested lambdas could be avoided.</p>

<p>Also, the <code>let</code>, and <code>join</code> clauses aren't supported yet. The <code>into</code> clause can't be supported without the help of polymorhpic lambdas.</p>
      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/pfultz2">pfultz2</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>