{"name":"Linq","tagline":"Linq for list comprehension in C++","body":"Linq\r\n====\r\n\r\nLinq for list comprehension in C++, provides an implementation of linq for C++. Currently it only supports C++ ranges, but it does support both the extension and query methods for linq. Here's an example:\r\n\r\n```c#\r\nstruct student_t\r\n{\r\n    std::string last_name;\r\n    std::vector<int> scores;\r\n};\r\n\r\nstd::vector<student_t> students = \r\n{\r\n    {\"Omelchenko\", {97, 72, 81, 60}},\r\n    {\"O'Donnell\", {75, 84, 91, 39}},\r\n    {\"Mortensen\", {88, 94, 65, 85}},\r\n    {\"Garcia\", {97, 89, 85, 82}},\r\n    {\"Beebe\", {35, 72, 91, 70}} \r\n};\r\n\r\nauto scores = LINQ(from(student, students) \r\n                   from(score, student.scores) \r\n                   where(score > 90) \r\n                   select(std::make_pair(student.last_name, score)));\r\n\r\nfor (auto x : scores)\r\n{\r\n    printf(\"%s score: %i\\n\", x.first.c_str(), x.second);\r\n}\r\n```\r\n\r\nThe C++ code above will outputs this(yes that is C++ code above):\r\n\r\n    Omelchenko score: 97\r\n    O'Donnell score: 91\r\n    Mortensen score: 94\r\n    Garcia score: 97\r\n    Beebe score: 91\r\n\r\n\r\nExtension\r\n---------\r\n\r\nExtensions are implemented using the `|` pipe operator. This allows them to be applied to any range, without requiring inherting from some special base class. So extensions can work like this:\r\n\r\n```c++\r\nvector<int> numbers = { 1, 2, 3, 4, 5, 6, 7, 8 };\r\nauto r = numbers \r\n        | linq::where([](int x) { return x > 2; }) \r\n        | linq::select([](int x) { return x * x; });\r\n```\r\nThe extension methods supported are:\r\n\r\n*   aggregate(reducer)\r\n*   aggregate(seed, reducer)\r\n*   aggregate(seed, reducer, selector)\r\n*   all(predicate)\r\n*   any(predicate)\r\n*   average()\r\n*   concat(range)\r\n*   containe(element)\r\n*   count()\r\n*   count(predicat)\r\n*   default_if_empty()\r\n*   default_if_empty(default_value)\r\n*   distinct()\r\n*   element_at(index)\r\n*   except(range)\r\n*   find(element)\r\n*   first()\r\n*   first(predicate, value)\r\n*   first_or_default()\r\n*   first_or_default(predicate)\r\n*   group_by(key_selector)\r\n*   group_by(key_selector, element_selector)\r\n*   group_join(range, outer_key_selector, inner_key_selector, result_selector)\r\n*   intersect(range)\r\n*   join(range, outer_key_selector, inner_key_selector, result_selector)\r\n*   keys()\r\n*   last()\r\n*   last(predicate, value)\r\n*   last_or_default()\r\n*   last_or_default(predicate)\r\n*   max()\r\n*   min()\r\n*   order_by(selector)\r\n*   order_by_descending(selector)\r\n*   reverse()\r\n*   select(selector)\r\n*   select_many(selector)\r\n*   sequence_equal(range)\r\n*   single()\r\n*   single_or_default()\r\n*   skip(count)\r\n*   skip_while(predicate)\r\n*   sum()\r\n*   take(count)\r\n*   take_while(predicate)\r\n*   then_by(selector)\r\n*   then_by_descending(selector)\r\n*   to_container()\r\n*   union(range)\r\n*   values()\r\n*   where(predicate)\r\n*   zip(range)\r\n*   zip(range, selector)\r\n\r\nThe library also provides a `range_extension` class, that can be used to write your own extensions, as well. First just define the function as a function object class, like this:\r\n```c++\r\nstruct contains_t\r\n{\r\n    template<class Range, class T>\r\n    bool operator()(Range && r, T && x) const\r\n    { return (r | linq::find(x)) != boost::end(r); };\r\n};\r\n```\r\nThen initialize the extension using static initialization:\r\n```c++\r\nrange_extension<contains_t> contains = {};\r\n```\r\nThen the extension can be used like this:\r\n```c++\r\nif (numbers | contains(5)) printf(\"We have a 5\");\r\n```\r\n\r\nQuery\r\n-----\r\n\r\n### from\r\nAll linq queries must start with a `from` statement. This specifies the variable name to be used for the lambdas and the container that the queries will be applied to. Also, multiple `from` statements can be used.\r\n```c#\r\nstruct student\r\n{\r\n    std::string name;\r\n    std::vector<int> grades;\r\n\r\n    student() {}\r\n\r\n    template<class Range>\r\n    student(std::string name, Range&& r)\r\n    : name(name), grades(boost::begin(r), boost::end(r))\r\n    {}\r\n};\r\n\r\nstd::vector<student> students =\r\n{\r\n    student(\"Bob\", { 90, 100, 75 })\r\n    student(\"Tom\", { 92, 81, 70 })\r\n    student(\"Terry\", { 105, 98, 94 })\r\n};\r\n\r\n// { 90, 100, 75, 92, 81, 70, 105, 98, 94 }\r\nauto q = LINQ(from(s, students) from(g, s.grades) select(g));\r\n```\r\n### where\r\nThe where clause returns the element that matches the predicate. It is optional but must come after a `from` clause and should be before a `select` clause if there is one.\r\n\r\n```c#\r\nvector<int> v = { 1, 3, 4, 5 };\r\n// { 1, 3, 5 }\r\nauto q = LINQ(from(i, v) where(i % 2));\r\n```\r\n\r\n### select\r\nThe select clause applies a transformation to the elements. It is optional also, but should be the very last clause.\r\n\r\n```c#\r\nstd::vector<int> v = { 1, 2, 4 };\r\n// { 3, 6, 24 }\r\nauto q = LINQ(from(x, v) select(x * 3));\r\n```\r\n\r\n### orderby\r\nThe `orderby` clause lets you specify elements to order the range by. Also `ascending` or `descending` can be preceded by the selector in order to specify the direction of ordering. The default is ascending.\r\n```c#\r\nstruct person\r\n{\r\n    std::string name;\r\n    int age;\r\n\r\n    person() {}\r\n\r\n    person(std::string name, int age)\r\n    : name(name), age(age)\r\n    {}\r\n};\r\n\r\nstd::vector<person> people =\r\n{\r\n    person(\"Tom\", 25),\r\n    person(\"Bob\", 22),\r\n    person(\"Terry\", 37),\r\n    person(\"Jerry\", 22)\r\n}\r\n//  { \"Jerry\", \"Bob\", \"Tom\", \"Terry\" }\r\nauto q = LINQ(from(p, people) orderby(p.age, descending p.name) select(p.name));\r\n```\r\n\r\n### group\r\nThe `group` clause groups the elements of a sequence. The first parameter is the key selector, and the second one is the value selector.\r\n```c#\r\nstruct person\r\n{\r\n    std::string name;\r\n    int age;\r\n\r\n    person() {}\r\n\r\n    person(std::string name, int age)\r\n    : name(name), age(age)\r\n    {}\r\n};\r\n\r\nstd::vector<person> people =\r\n{\r\n    person(\"Tom\", 25),\r\n    person(\"Bob\", 22),\r\n    person(\"Terry\", 37),\r\n    person(\"Jerry\", 22)\r\n}\r\nauto q = LINQ(from(p, people) group(p.age, p.name));\r\n```\r\n\r\nInstallation\r\n------------\r\n\r\nJust copy the `linq.h` and `linq` folder to the include directory for your compiler. Then just include the `linq.h` header, to include all of linq.\r\n\r\nThe `linq/extensions.h` header will just include whats needed for the extension methods, without the query syntax, and the `linq/query.h` will include the query syntax as well.\r\n\r\nRequirements\r\n------------\r\n\r\nFor full support it requires clang or gcc, and boost. There is partial support for visual studio. Visual studio doesn't support the `default_if_empty`, `group_by`, `group_join`, `join`, `order_by`, `select_many`, and `then_by` extensions, and it doesn't support `orderby`, `group`, and nested from clauses. Perhaps some visual studio wizards could help find workarounds for msvc bugs.  \r\n\r\n\r\nLimitations\r\n-----------\r\n\r\nMultiple `from` statements are implemented using nested lambdas. However, because of a [bug](http://connect.microsoft.com/VisualStudio/feedback/details/634688) in MSVC 2010, nested lambas don't work(This should be fixed in MSVC 2012, but I haven't tested it). If there is a way to implement transparent identifiers in C++, nested lambdas could be avoided.\r\n\r\nAlso, the `let`, and `join` clauses aren't supported yet. The `into` clause can't be supported without the help of polymorhpic lambdas.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}