{"name":"Linq","body":"Linq\r\n====\r\n\r\nLinq and list comprehension for C++:\r\n\r\n```c#\r\nstd::vector<int> numbers = { 1, 2, 3, 4 };\r\nauto r = LINQ(from(x, numbers) where(x > 2) select(x * x));\r\nfor (auto x : r) printf(\"%i\\n\", x);\r\n```\r\n\r\nThe C++ code above will outputs this(yes that is C++ code above):\r\n\r\n    9\r\n    16\r\n\r\n\r\nMotivation\r\n----------\r\n\r\nList comprehension can already be done using Boost.Range and lambda, like this:\r\n\r\n```c#\r\nauto r = numbers \r\n        | boost::adaptors::filtered([](int x) { return x > 2; }) \r\n        | boost::adaptors::transformed([](int x) { return x * x; });\r\n```\r\n\r\nHowever, this is can be very hard to read, and is filled with a lot of boilerplate lambda code. Also, if the type of the container is much longer or more complex it can get even harder to read. Linq provides syntatic surger to make the statement shorter and more concise:\r\n\r\n```c#\r\nauto r = LINQ(from(x, numbers) where(x > 2) select(x * x));\r\n```\r\n\r\nThis will deduce the type of the `numbers` range, and reuse that for all the lambdas. (This is why its important to put select at the end)\r\n\r\nUsage\r\n-----\r\n\r\nTo use Linq, just include the \"linq.h\" file. Then all you linq queries must be placed inside the `LINQ()` macro. The result of the linq query is a range of elements that match the query. All queries are lazy evaluated. Since there is no copy of the range, the query cannot outlive the range.\r\n\r\n\r\n### from\r\nAll linq queries must start with a `from` statement. This specifies the variable name to be used for the lambdas and the container that the quieries will be applied to. \r\n\r\n```c#\r\nLINQ(from(variable, container) ... );\r\n```\r\n\r\n### where\r\nThe where clause returns the element that matches the predicate. It is optional but must come after a `from` clause and should be before a `select` clause if there is one.\r\n\r\n ```c#\r\nLINQ(from(variable, container) where(predicate) ... );\r\n```\r\n\r\n### select\r\nThe select clause applies a tranformation to the elements. It is optional also, but should be the very last clause.\r\n\r\n ```c#\r\nLINQ( ... select(transformation) );\r\n```\r\n\r\nRequirements\r\n------------\r\n\r\nThis will work on MSVC 2010 or later, clang, and gcc. The compiler needs to be set to C++11 mode, because it requires lambda support. It also requires boost. It was tested with boost 1.49, but may work on earlier versions. \r\n\r\nLimitations\r\n-----------\r\n\r\nAs of now, it doesn't support cartesian products. I hope to add that in the future(any help on developing a cartesian product iterator would be helpful). So you cannot write this:\r\n\r\n```c#\r\n//This is not supported yet\r\nLINQ(from(x, list1) from(y, list2) select(x*y));\r\n```\r\n\r\nAlso, the `sortedby` clause is not suported yet.\r\n\r\n","tagline":"Linq and list comprehension for C++","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}